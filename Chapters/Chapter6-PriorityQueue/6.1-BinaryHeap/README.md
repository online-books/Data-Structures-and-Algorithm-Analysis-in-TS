<!-- @format -->

## 优先队列

优先队列是允许至少两种操作的数据结构：$Insert$和$DeleteMin$。$Insert$操作等价于$Enqueque$（入队）,而$DeleteMin$则是找出、返回和删除队列中最小的元素，等价于队列中的$Dequeue$（出队）操作。

<image src="../../../Assets/Images/ch6/6-1.png" />

图 6-1 优先队列的基本模型

### 二叉堆

---

二叉堆是优先队列最普遍的实现，简称堆。二叉堆有两个性质：结构性和堆序性。对堆的一次操作可能破坏这两个性质中的一个。因此，对堆的操作要保证这两个性质都被满足才能终止。

#### 结构性质

堆是一棵被完全填满的二叉树，这样的树称为**完全二叉树**。一棵高为$h$的完全二叉树有$2^h$到$2^{h+1}$个节点。这意味着完全二叉树的高是$\log N$

<image src="../../../Assets/Images/ch6/6-2.png" />

图 6-2 一棵完全二叉树

因为完全二叉树很有规律，所以它可以用一个数组表示。图 6-3 对应上图中的堆。

<image src="../../../Assets/Images/ch6/6-3.png" />

图 6-3 完全二叉树的数组实现

#### 堆序性质

---

由于我们想要在堆中快速找出最小元，因此最小元应该在根上。如果任意子树也是一个堆，那么任意节点就应该小于它的所有后裔。

由此我们可以得到堆序性质。在一个堆中，对于每一个节点$X$，$X$的父节点中的关键字小于或等于$X$中的关键字，根节点除外（它没有父节点）。在下图中左边的树是一个堆而右边的树不是。根据堆序性质，最小元总可以在根上找到，因此我们以常数时间完成$FindMin$操作。

<image src="../../../Assets/Images/ch6/6-4.png" />

图 6-4 两棵完全树（只有左边的树是堆）

### 基本的堆操作

---

#### Insert

为将一个元素$X$插入到堆中，我们在下一个空闲位置创建一个空穴，如果$X$可以放在该空穴中而不破坏堆序性，那么插入完成，否则我们把空穴的父节点上的元素移入该空穴中。继续该过程直到$X$能被插入到空穴中为止。这种策略叫做**上滤**：新元素在堆中上滤直到找出正确的位置。如图 6-5 所示。

<image src="../../../Assets/Images/ch6/6-5.png" />

图 6-5 上滤过程

#### DeleteMin

当删除一个最小元时，在根节点产生一个空穴，由于现在堆中少了一个元素，因此堆中的最后一个元素$X$必须移动到堆的某个地方。如果$X$可以放在空穴中，那么$DeleteMin$完成。否则就将空穴的两个子节点中较小者移入空穴，重复该步骤直到$X$可以被放到空穴中。这种策略叫做**下滤**。如图 6-6 所示。

<image src="../../../Assets/Images/ch6/6-6.png" />

图 6-6 下滤过程

### 代码位置

---

SourceCode/PriorityQueue/BinaryHeap.ts
