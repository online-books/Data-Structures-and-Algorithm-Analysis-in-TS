<!-- @format -->

## 二叉堆

堆有两个性质，即结构性和堆序性。正如 AVL 数一样，对堆的一次操作可能破坏这两个性质中的一个。因此，堆的操作必须要堆的所有性质都被满足才能终止。

### 结构性质

堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树成为**完全二叉树**。

<image src="../../../Images/ch6/6-1-1.png">

图 6-1-1 一棵完全二叉树

容易证明，一棵高为$h$的完全二叉树有$2^h$到$2^{h+1}-1个节点$。这意味着完全二叉树的高是$logN$。

因为完全二叉树很有规律，所以它可以用一个数组表示。图 6-2-2 对应上图中的堆。

<image src="../../../Images/ch6/6-1-2.png">

图 6-1-2 完全二叉树的数组实现

### 堆序性质

---

使操作快速被执行的性质是**堆序性**。由于我们想要快速找出最小元，因此最小元应该在根上。如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它的所有后裔。

应用这个逻辑，我们得到堆序性质。在一个堆中，对于每一个节点$X$，$X$的父亲中的关键字小于或等于$X$中的关键字，根节点除外。在下图中左边的树是一个堆而右边的树不是

<image src="../../../Images/ch6/6-1-3.png">

图 6-1-3 两棵完全树（只有左边的树是堆）

### 基本的堆操作

---

#### Insert（插入）

为将一个元素$X$插入到堆中，我们在下一个空闲位置创建一个空穴，如果$X$可以放在该空穴中而不破坏堆序性，那么插入完成，否则我们把空穴的父节点上的元素移入该空穴中。继续该过程直到$X$能被插入到空穴中为止。这种策略叫做**上滤**：新元素在堆中上滤直到找出正确的位置。图 6-2-4 演示了一次上滤过程。

<image src="../../../Images/ch6/6-1-4.png">

图 6-1-4 尝试插入 14：创建一个空穴，再将空穴上滤

#### DeleteMin（删除最小元）

当删除一个最小元时，在根节点产生一个空穴，由于现在堆中少了一个元素，因此堆中的最后一个元素$X$必须移动到堆的某个地方。如果$X$可以放在空穴中，那么$DeleteMin$完成。否则我们将空穴的两个儿子中较小者移入空穴，重复该步骤直到$X$可以被放到空穴中。因此，我们的做法是将$X$置入沿着从根开始包含最小儿子的一条路径上的一个正确位置。这种一般的策略叫做**下滤**。图 6-2-5 至 6-2-7 演示了一次$DeleteMin$操作。

<image src="../../../Images/ch6/6-1-5.png">

图 6-1-5 在根处建立空穴

<image src="../../../Images/ch6/6-1-6.png">

图 6-1-6 下滤过程中的接下来两步

<image src="../../../Images/ch6/6-1-7.png">

图 6-1-7 下滤过程中的最后两步

### 代码位置

---

SourceCode/PriorityQueue/BinaryHeap.ts
