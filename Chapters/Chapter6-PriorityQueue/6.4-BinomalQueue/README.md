<!-- @format -->

## 二项队列

虽然左式堆和斜堆每次操作花费$O(\logN)$时间，这有效地支持了合并、插入和删除最小元，但还有改进的余地。因为我们知道，二叉堆以每次操作花费常数平均时间支持插入。二项队列支持所有这三种操作，每次操作的最坏情形运行时间为$O(\logN)$，而插入操作平均花费常数时间。

### 二项队列结构

---

二项队列不同于我们已经看到的所有优先队列的实现之处在于，一个二项队列不是一棵堆序的树，而是堆序树的集合，称为**森林**。堆序树中的每一棵都是有约束的形式，叫做**二项树**。每一个高度上至多存在一棵二项树。高度为$0$的二项树是一棵单节点树；高度为$k$的二项树$B_k$通过将一棵二项树$B_{k-1}$连接到另一棵二项树$B_{k-1}$的根上而构成。图 6-4-1 显示二项树$B_0$、$B_1$、$B_2$、$B_3$以及$B_4$。

<image src="../../../Assets/Images/ch6/6-4-1.png">

图 6-4-1 二项树$B_0$、$B_1$、$B_2$、$B_3$以及$B_4$

从图中看到，二项树$B_k$由一个带有儿子$B_0,B_1,...,B_{k-1}$的根组成。高度为$k$的二项树恰好有$2^k$个节点，而在深度$d$处的节点数是二项系数$(^k_d)$。如果我们把堆序施加到二项树上并允许任意高度上最多有一棵二项树，那么我们能够用二项树的集合唯一地表示任意大小的优先队列。

### 二项队列操作

---

最小元可以通过搜索所有树的根来找出。由于最多有$\logN$棵不同的树，因此最小元可以时间$O(\logN)$找到。如果我们记住当最小元在其他操作期间变化时更新它，那么我们也可以保留最小元的信息并以$O(1)$时间执行该操作。

合并操作基本上是通过将两个队列加到一起来完成的。令$H_1$、$H_2$是两个要被合并的二项队列，$H_3$是新的二项队列。如果$H_1$有一棵高度为$k$的二项树而$H_2$没有，则将$H_1$中高度为$k$的二项树添加到$H_3$中；同理，如果$H_2$有一棵高度为$k$的二项树而$H_1$没有，则将$H_2$中高度为$k$的二项树添加到$H_3$中；而如果$H_1$与$H_2$都存在高度为$k$的二项树，那么我们可以将它们合并，让大的根的二项树成为小的根的二项树的子树，从而建立一棵高度为$k+1$的二项树；如果由于根合并导致存在三棵高度相同的树，即$H_1$和$H_2$原有的两棵二项树以及上一步形成的一棵二项树，则我们将其中一棵放到$H_3$中，合并其他两棵二项树。依此合并直到$H_1$、$H_2$中所有的二项树都添加到$H_3$中。

<image src="../../../Assets/Images/ch6/6-4-2.png">

图 6-4-2 二项队列$H_1$

<image src="../../../Assets/Images/ch6/6-4-3.png">

图 6-4-3 二项队列$H_2$

<image src="../../../Assets/Images/ch6/6-4-4.png">

图 6-4-1 二项队列$H_3$：合并$H_1$和$H_2$的结果

插入实际上是特殊情形的合并。我们只要创建一棵单节点树并执行依次合并。这种操作的最坏运行时间是$O\log(N)$。

删除最小元可以通过首先找出一棵具有最小根的二项树来完成。令该树为$B_k$，并令原始的优先队列为$H$。我们从$H$的树的森林中出去二项树$B_k$，形成新的二项队列$H'$。再除去$B_k$的根，得到一些二项树$B_0,B_1,B_2,...,B_{k-1}$，它们共同形成优先队列$H''$。合并$H'$和$H''$，操作结束。$DeleteMin$操作将原二项队列一分为二，找出含有最小元的树并穿件队列$H'$和$H''$花费时间$O(\logN)$。合并这两个队列又花费$O(\logN)$，因此整个$DeleteMin$操作花费时间$O(\logN)$。

### 代码位置

---

SourceCode/PriorityQueue/BinomialQueue/BinomialQueue.ts
