<!-- @format -->

## 二项队列

虽然左式堆和斜堆能够以$O(\log N)$时间进行合并、插入和删除最小元的操作，但还有改进的余地。因为二叉堆以每次操作花费常数平均时间支持插入。二项队列的合并、删除最小元操作的最坏情形运行时间为$O(\log N)$，而插入操作平均花费常数时间。

### 二项队列结构

---

二项队列和前面所实现的所有优先队列不同的是，一个二项队列不是一棵堆序的树，而是堆序树的集合，称为**森林**。堆序树中的每一棵树，叫做**二项树**。森林中的每棵二项树的高度都不相同。高度为$0$的二项树是一棵单节点树；高度为$k$的二项树$B_k$通过将一棵二项树$B_{k-1}$连接到另一棵二项树$B_{k-1}$的根上而构成。如图 6-13 所示 。

<image src="../../../Assets/Images/ch6/6-13.png">

图 6-13 二项树$B_0$、$B_1$、$B_2$以及$B_3$

从图中看到，二项树$B_k$由$B_0,B_1,...,B_{k-1}$和一个根节点组成，高度为$k$的二项树恰好有$2^k$个节点。如果每棵二项树都有堆序性质并且任意高度上最多有一棵二项树，那么二项树的集合就能唯一地表示任意大小的优先队列。比如大小为 7 的优先队列可以用森林$B_2,B_1,B_0$表示。这种表示可以写成 111，它不仅代表 7 的二进制形式，也说明该优先队列由$B_2,B_1,B_0$组成。

### 二项队列操作

---

#### 合并

二项队列的合并操作基本上是将两个队列中相同高度的二项树合并成一棵树完成的。假设$H_1$、$H_2$是两个要被合并的二项队列，$H_3$是新的空二项队列，如图 6-14 所示。

<image src="../../../Assets/Images/ch6/6-14.png">

图 6-14 两个二项队列$H_1$和$H_2$

那么在合并过程中会有如下几种情况：

-   a.$H_1$有一棵高度为$k$的二项树而$H_2$没有，则将$H_1$中高度为$k$的二项树添加到$H_3$中；
-   b.$H_2$有一棵高度为$k$的二项树而$H_1$没有，则将$H_2$中高度为$k$的二项树添加到$H_3$中；
-   c.$H_1$与$H_2$都存在高度为$k$的二项树，那么就将这两棵二项树合并，让大的根的二项树成为小的根的二项树的子树，形成一棵高度为$k+1$的二项树；
-   d.$H_1$和$H_2$都存在高度为$k$的二项树以及情形 c 所合并而来的高度为$k$二项树，则将其中一棵树放到$H_3$中，再执行情形 c。

<image src="../../../Assets/Images/ch6/6-15.png">

图 6-15 二项队列的合并

#### 插入

插入实际上是特殊情形的合并。首先创建一棵单节点二项树树，然后与二项队列中的二项树依次合并即可。如果要插入的优先队列中不存在的最小的二项树是$B_i$，那么插入的运行时间为$O(i+1)$，其最坏运行时间是$O\log N$。

<image src="../../../Assets/Images/ch6/6-16.png">

图 6-16 二项队列的插入

#### 删除最小元

在二项队列中，由于最多有$\log N$棵不同的树，因此最小元可以通过搜索所有二项树的根以时间$O(\log N)$找到。

假设优先队列$H$中具有最小元的二项树为$B_k$，那么对应的删除过程就是：

1. 从$H$中删除二项树$B_k$，形成新的二项队列$H'$
2. 删除二项树$B_k$的根节点，得到二项树$B_0,B_1,B_2,...,B_{k-1}$，这些二项树组成优先队列$H''$
3. 合并$H'$和$H''$

删除最小元操作将原二项队列一分为二，找出含有最小元素的二项树并创建队列$H'$和$H''$花费时间$O(\log N)$。合并这两个队列又花费$O(\log N)$，因此整个操作花费时间的为$O(\log N)$。

<image src="../../../Assets/Images/ch6/6-17.png">

图 6-17 二项队列的删除最小元：删除最小元的二项树后形成$H'$和$H''$两个二项队列

<image src="../../../Assets/Images/ch6/6-18.png">

图 6-18 二项队列的删除最小元：合并$H'$和$H''$两个二项队列

### 代码位置

---

SourceCode/PriorityQueue/BinomialQueue/BinomialQueue.ts
