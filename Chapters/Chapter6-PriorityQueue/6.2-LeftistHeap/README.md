<!-- @format -->

## 左式堆

二叉堆除不能执行$Find$外，最明显的缺点是：将两个堆合并成一个堆是困难的操作。原因在于，合并似乎需要把一个数组拷贝到另一个数组中，对于相同大小的堆这将花费时间$\Theta(N)$。

左式堆具有和二叉堆相同的堆序性，二叉堆也是二叉树，其和二叉树间的唯一区别是：左式堆不是理想平衡的，实际上是趋向于非常不平衡。

### 左式堆的性质

---

任一节点的零路径长（null path length,$NLP$）$NLP(X)$定义为从$X$到一个没有两个儿子的节点的最短路径长。因此，具有$0$个或$1$个儿子的节点的$NLP$为$0$，而$NLP(NULL)=-1$。任一节点的零路径长比它的诸儿子的零路径长的最小值多$1$。

<image src="../../../Assets/Images/ch6/6-2-1.png">

图 6-2-1 两个树的零路径长，只有左边的树是左式树

左式堆的性质是：对于堆中的每一个节点$X$，左儿子的零路径长至少与右儿子的零路径长一样大。$N$个节点的左式树有一条右路径最多含有$\log(N+1)$个节点。对于左式堆的操作的一般思路是将所有的工作放到有路径上进行，它保证树深短。

### 左式堆的操作

---

左式堆的基本操作是合并。插入只是合并的特殊情形，因为我们可以把插入看作是单节点堆与一个大堆的$Merge$。假设我们的输入是两个左式堆$H_1$和$H_2$，见图 6-2-2。如果这两个堆中有一个是空堆，则我们可以直接返回另一个堆。否则，为了合并这两个根，我们首先将具有大的根值的堆与具有小值的根植的堆的右子堆合并。在本例中，我们递归地将$H_2$与$H_1$中根在$8$处的右子堆合并，得到图 6-2-3 中的堆。

<image src="../../../Assets/Images/ch6/6-2-2.png">

图 6-2-2 两个左式堆$H_1$和$H_2$

<image src="../../../Assets/Images/ch6/6-2-3.png">

图 6-2-3 将$H_2$和$H_1$的右子堆合并的结果

现在，我们将这个新的堆成为$H_1$的根的右儿子，见图 6-2-4。虽然最后得到的堆满足堆序性质，但它不是左式堆，因为根的左子树的零路径长为$1$而根的右子树的零路径长为$2$。因此，左式堆的性质在根处被破坏。不过，容易看到，树的其余部分必然是左式的。由于递归步骤，根的右子树是左式的，根的左子树也没有变化。因此我们只需要堆根进行调整就可以了。使整个树是左式的做法如下：只要交换根的左儿子和右子（图 6-2-5）并更新零路径长。

<image src="../../../Assets/Images/ch6/6-2-4.png">

图 6-2-4 $H_1$接上图 6-2-2 中的左式堆作为右儿子的结果

<image src="../../../Assets/Images/ch6/6-2-5.png">

图 6-2-5 交换$H_1$的根的儿子

执行合并的时间与右路径的长的和成正比，因为在递归调用期间堆每一个被访问的节点执行的是常数工作量。因此，我们我们得到合并两个左式堆的时间界是$O(\logN)$。

为了执行$DeleteMin$，只要除掉根而得到两个堆，然后将这两个堆合并。因此，执行一次$DeleteMin$的时间为$O(\logN)$。

### 代码位置

---

SourceCode/PriorityQueue/leftist-heap
