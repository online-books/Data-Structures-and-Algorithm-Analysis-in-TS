<!-- @format -->

## 左式堆

二叉堆除不能执行$Find$外，最明显的缺点就是将两个堆合并成一个堆很困难。原因在于合并需要把一个数组拷贝到另一个数组中，对于相同大小的堆花费时间是$\Theta(N)$。

左式堆具有和二叉堆相同的堆序性。二叉堆也是二叉树，其和二叉树间的唯一区别是：左式堆不是理想平衡的，而是趋向于非常的不平衡。

### 左式堆的性质

---

任一节点的**零路径长**（null path length,$npl$）$npl(X)$定义为从$X$到一个没有两个儿子的节点的最短路径长。因此，具有$0$个或$1$个儿子的节点的$npl$为$0$，并且$npl(null)=-1$。任一节点的零路径长比它的诸儿子的零路径长的最小值多$1$。

<image src="../../../Assets/Images/ch6/6-7.png">

图 6-7 两个树的零路径长，只有左边的树是左式树

左式堆的结构性质是：对于堆中的每一个节点$X$，左儿子的零路径长至少与右儿子的零路径长一样大。这个性质使得左式堆趋向于加深左路径而且右路径更短。沿左式堆的右路径就是堆中的最短路径。

在右路径上有$r$个节点的左式树必然至少有有$2^r-1$个节点。也就是说，$N$个节点的左式树的右路径最多含有$log(N+1)$个节点。因此对于左式堆的操作的一般思路是在路径上进行，它保证树深最短。

### 左式堆的操作

---

左式堆的基本操作是合并。插入也只是合并的特殊情形，因为我们可以把插入看作是单节点堆与一个大的堆的合并操作。假设我们的输入是两个左式堆$H_1$和$H_2$，如图 6-8。

<image src="../../../Assets/Images/ch6/6-8.png">

图 6-8 两个左式堆$H_1$和$H_2$

在堆的合并过程中，如果这两个堆中有一个是空堆，那么就直接返回另一个堆；否则就首先将具有大的根值的堆与具有小的根植的堆的右子堆合并。在这个例子中，我们递归地将$H_2$与$H_1$中节点值为 8 处的右子堆合并，得到图 6-9 中的堆。

<image src="../../../Assets/Images/ch6/6-9.png">

图 6-9 将$H_2$和$H_1$的右子堆合并的结果

虽然最后得到的堆满足堆序性质，但它不是左式堆，因为节点值为 7 处的左子树的零路径长为 0 而右子树的零路径长为 1 以及根的左子树的零路径长为 1 而根的右子树的零路径长为 2，导致合并后的树不满足左式堆的性质。不过，树的其余部分仍然是左式的。使整个树是左式的做法是：将不满足左式堆性质节点的左子树和右子树交换位置并更新其零路径长。如图 6-11 所示。

<image src="../../../Assets/Images/ch6/6-10.png">

图 6-10 对不满足左式堆性质的节点的左右子树进行交换

执行合并的时间与两个堆右路径的长的和成正比，因此合并两个左式堆的时间界是$O(\log N)$。

对于$DeleteMin$来说，只要删除根节点然后将根节点的左子堆和右子堆合并即可。

### 代码位置

---

[SourceCode/PriorityQueue/LeftistHeap/LeftistHeap.ts](../../../SourceCode/PriorityQueue/LeftistHeap/LeftistHeap.ts)
