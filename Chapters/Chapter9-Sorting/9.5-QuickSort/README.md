<!-- @format -->

## 快速排序

正如它的名字所标示的，快速排序是在实践中最快的已知排序算法，它的平均时间是$O(N\logN)$。该算法之所以快，主要是由于非常精炼和高度优化的内部循环。它的最坏情形的性能为$O(N^2)$。像归并排序一样，快速排序也是一种分治的递归算法。将数组$S$排序的基本算法由下列简单的四步组成：

1.  如果$S$中元素个数是$0$，则返回
2.  取$S$中任一元素$v$，称之为*枢纽元*(pivot)
3.  将$S- \lbrace v \rbrace$（$S$中其余元素）分成两个不相交的集合：$S_1= \lbrace x\in S- \lbrace v \rbrace, x\leq v \rbrace$和$S_2= \lbrace x\in S- \lbrace v \rbrace, x\geq v \rbrace$。
4.  返回 $quicksort(S_1)$后，继随$v$，继而$quicksort(S_2)$。

由于对那些等于枢纽元的元素的处理，第（3）步分割的描述不是唯一的，一部分好的实现方式是将这种情形尽可能有效地处理。直观地看，我们希望把枢纽元的大约一半的关键字分配到$S_1$中，而另外的一半分到$S_2$中，很像我们希望二叉查找数保持平衡一样。

### 选取枢纽元

---

#### 一种错误的方法

通常的、没有经过充分考虑的选择是将第一个元素用作枢纽元。如果输入是随机的，那么这是可以接受的，但如果输入是预排序或反序的，那么这样的枢纽元就产生一个劣质的分割，因为所有的元素不是都被划入$S_1$就是都被划入$S_2$。更有甚者，这种情况可能发生在所有的递归调用中，那么快速排序花费的时间将是二次的，但实际上却根本没干什么事。

#### 一种安全的做法

一种安全的做法是随机选取枢纽元，因为随机的枢纽元不可能总在接连不断地产生劣质的分割，除非随机数生成器有问题。

#### 三数中值分割法

一组$N$个数的中值是第$[N/2]$个最大的数。枢纽元的最好的选择是数组的中值，不过这很难算出且明显减慢快速排序的速度。因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。

### 分割策略

---

有几种分割策略用于实践，但此处描述的分割方法能够给出最好的结果。该法的第一步是通过将枢纽元与最后的元素交换使得是纽元离开要被分割的数据段。$i$从第一个元素开始而$j$从倒数第二个元素开始。在分割阶段要做的就是把所有小于枢纽元的元素移到数组左边而把大的元素移到数组右边。

<image src="../../../Assets/Images/ch7/7-5-1.png"/>

图 7-5-1 枢纽元选取后的初始状态

当$i$在$j$的左边时，我们将$i$右移，移过那些小于或等于枢纽元的元素，并将$j$左移，移过那些大于或等于枢纽元的元素。当$i$和$j$停止时，$i$指向一个大元素而$j$指向一个小元素。如果$i$在$j$的左边，那么将这两个元素互换，其效果是把一个大的元素移向右边而把一个小的元素移到左边。重复该过程直到$i$和$j$彼此交错位置。

<image src="../../../Assets/Images/ch7/7-5-2.png"/>

图 7-5-2 交换$i$和$j$指向的元素

分割的最后一步是将枢纽元与$i$所指向的元素交换。在最后一步，当枢纽元与$i$所指向的元素交换时，在位置$P<i$的每一个元素都必然是小元素，在位置$P>i$上的元素必然都是大元素。

<image src="../../../Assets/Images/ch7/7-5-3.png"/>

图 7-5-3 交换枢纽元与$i$所指向的元素

### 小数组

---

对于很小的数组$(N\leq20)$，快速排序不如插入排序好，因为快速排序是递归的，这样的情形还经常发生。通常的解决方法是对小的数组不递归地使用快速排序，而代之以插入排序这样对小数组有效的排序算法。

### 快速排序的分析

---

快速排序的运行时间等于两个递归调用的运行时间加上花费在分割上的线性时间（枢纽元的选取近花费常数时间）。我们能得到基本的快速排序关系：

$$T(N)=T(i)+T(N-i-1)+c \cdot N \tag{1}$$

#### 最坏情况的分析

枢纽元始终是最小元素。此时$i=0$，那么递推关系为：

$$T(N)=T(N-1)+c\cdot N(N>1) \tag{2}$$

反复使用方程 1，我们得到：

$$T(N-1)=T(N-2)+c\cdot （N-1） \tag{3}$$
$$T(N-2)=T(N-3)+c\cdot （N-2） \tag{4}$$
$$ \vdots$$
$$T(2)=T(1)+c(4) \tag{5}$$

将所有这些方程相加，得到：

$$T(N)=T(1)+c\sum_{i=2}^{N}i=O(N^2) \tag{6}$$

#### 最好情况的分析

在最好的情况下，枢纽元正好位于中间。我们假设两个子数组恰好各为原数组的一半大小，那么得到：

$$T(N)=2T(N/2)+c\cdot N \tag{7}$$

用$N$去除方程 5 的两边，得到：
$$\frac{T(N)}{N}=\frac{T(N/2)}{N/2}+c \tag{8}$$

我们反复套用方程 6，得到：

$$\frac{T(N/2)}{N/2}=\frac{T(N/4)}{N/4}+c \tag{9}$$
$$\frac{T(N/4)}{N/4}=\frac{T(N/8)}{N/8}+c \tag{10}$$
$$ \vdots$$
$$\frac{T(2)}{2} =\frac{T(1)}{1}+c(11)$$

将方程 5-9 相加后得到：
$$\frac{T(N)}{N}=\frac{T(1)}{1}+c \cdot \logN \tag{12}$$

由此得到：
$$T(N)=N \cdot T(1)+c \cdot N\logN \tag{13}$$

#### 平均情况的分析

对于平均情况，我们假设$S$中每个元素的大小是等可能的，因此每个大小均有概率$\frac{1}{N}$。由该假设可知，$T(i)$与$T(N-i+1)$的平均值为$\frac{1}{N} \cdot \sum_{j=0}^{N-1}T(j)$。此时方程 1 变成：

$$T(N)=\frac{2}{N}\cdot \sum_{j=0}^{N-1}T(j)+c \cdot N \tag{14}$$

用$N$乘以方程 14，则有
$$NT(N)=2  \sum_{j=0}^{N-1}T(j)+c \cdot N^2 \tag{15}$$
$$(N-1)T(N-1)=2  \sum_{j=0}^{N-2}T(j)+c \cdot (N-1)^2 \tag{16}$$

用方程 15 减去方程 16，得到：
$$NT(N)-(N-1)T(N-1)=2T(N-1)+2cN-c \tag{17}$$

移项、合并并除去无关紧要的$c$之后，得到：
$$NT(N)=(N+1)T(N-1)+2cN \tag{18}$$

再用$N(N+1)去除方程18，得到$
$$\frac{T(N)}{N+1}=\frac{T(N-1)}{N}+\frac{2c}{N+1} \tag{19}$$

然后进行叠缩，得到：
$$\frac{T(N-1)}{N}=\frac{T(N-2)}{N-1}+\frac{2c}{N} \tag{20}$$
$$\vdots$$
$$\frac{T(2)}{3}=\frac{T(1)}{2}+\frac{2c}{3} \tag{21}$$

将方程 19 到方程 21 相加后，得到：

$$\frac{T(N)}{N+1}=\frac{T(1)}{2}+2c\sum_{i=3}^{N+1}\frac{1}{i} \tag{22}$$
该和大约为$ln(N+1)+\gamma-\frac{3}{2}$，其中$\gamma \approx0.577$叫做欧拉常数，于是：
$$\frac{T(N)}{N+1}=O(\logN) \tag{23}$$
从而
$$T(N)=O(N\logN) \tag{24}$$

### 选择的线性期望时间算法

---

可以修改快速排序以解决*选择问题*，这个问题我们在第一章已经看到。通过使用优先队列，我们能够以时间$O(N+k\logN)$找到第$k$个最大元。对于查找中值的特殊情况，它给出$O(N\logN)$算法。

这里介绍的查找集合$S$中第$k$个最小元的算法几乎与快速排序相同。事实上，其前三步是一样的，这种算法叫*快速选择*。令$\lbrace S_i \rbrace$为$S_i$中元素的个数。快速选择的步骤如下：

1. 如果$\lbrace S_i \rbrace =1$，那么$k=1$，并将$S$中的元素作为答案返回。如果使用小数组的截止方法且$S \leq CUTOFF$，则将$S$排序并返回第$k$个最小元。
2. 选取一个枢纽元$v\in S$。
3. 将集合$S-\lbrace S_i \rbrace$分割成$S_1$和$S_2$，就像在快速排序中做的那样。
4. 如果$k \leq \lbrace S_i \rbrace$，那么第$k$个元素必定在$S_1$中。在这种情况下，返回$quickselect(S_1,k)$。如果$k=1+\lbrace S_i \rbrace$，那么枢纽元就是第$k$个最小元，我们将它作为答案返回。否则，这第$k$个最小元就在$S_2$中，它是$S_2$中的第$(k-\lbrace S_i \rbrace+1)$个最小元，我们进行一次递归调用并返回$quickselect(S-2,k-\lbrace S_i \rbrace+1)$。

与快速排序相比，快速选择只做了一次递归调用而不是两次。快速选择的最坏情况和快速排序的相同，也是$O(N^2)$,最坏情况发生在$S_1$和$S_2$有一个为空的时候。不过，平均运行时间是$O(N)$。

### 代码位置

---

SourceCode/Sort/QuickSort.ts
