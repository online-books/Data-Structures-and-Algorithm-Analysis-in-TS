<!-- @format -->

## 最小生成树

一个无向图$G$的最小生成树就是由该图的那些连接$G$的所有顶点的边构成的树，且其总价值最低。最小生成树存在当且仅当$G$是连通的。

<image src="../../../Images/ch9/9-4-1.png" />
图 9-4-1 图$G$和它的最小生成树

在最小生成树中，边的条数为$|V|-1$。最小生成树是一棵树，因为它无圈；因为最小生成树包含每一个顶点，所以它是生成树。此外，最小生成树是包含图的所有顶点的最小的树。

对于任一生成树$T$，如果将一条不属于$T$的边$e$添加进来，则产生一个圈。如果从该圈中除去任意一条边，则又恢复生成树的特性。如果边$e$的值比除去的边的值低，那么新的生成树的值就比原生成树的值低。如果在建立生成树时所添加的边在所有避免成圈的边中值最小，那么最后得到的生成树的值不能再改进，因为任意一条替代的边的值都大于等于已经存在于该生成树中的一条边的值。对于最小生成树，这种贪欲是成立的，下面介绍两种算法，它们的区别在于最小值的边的选取策略不同。

### Prim 算法

---

计算最小生成树的一种方法是使其连续地一步步长成。在每一步，都要把一个节点当作根并往上加边，这样也就把相关联的顶点加到增长中的树上。

算法在每一阶段都可以通过选择边$(u,v)$，使得$(u,v)$的值是所有$u$在树上但$v$不再树上的边的值中的最小者，从而找出一个新的顶点并把它添加到这棵树中。图 9-4-2 描述算法如何从$v_1$开始构建最小生成树。

<image src="../../../Images/ch9/9-4-2.png">

图 9-4-2 在每一步之后的 Prim 算法

Prim 算法基本上和求最短路径的 Dijkstra 算法一样。不用堆时的运行时间是$O(|V|^2)$，它对于稠密的图来说是最优的，使用二叉堆的运行时间是$O(|E|log|V|)$，对于稀疏的图它是一个好的界。
