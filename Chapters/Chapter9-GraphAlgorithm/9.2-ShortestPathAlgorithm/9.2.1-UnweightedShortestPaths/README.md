<!-- @format -->

## 无权最短路径

无权最短路径是赋权最短路径的特殊情形，因为我们可以为所有的边都赋权为$1$。 图 9-2-3 表示一个无权的图

<image src="../../../../Images/ch9/9-2-3.png">

图 9-2-3 一个无权有向图 G

假设我们要找出上图中$v_3$到所有其他顶点的最短路径长。首先找到所有与$v_3$距离为$1$的顶点。这些顶点可以通过查找与$v_3$邻接的那些顶点找到，得到$v_1$和$v_6$的最短路径长为$1$。然后，可以开始找出那些从$v_3$出发最短路径为$2$的顶点，即找出所有邻接到$v_1$和$v_6$的顶点，得到$v_2$和$v_4$的最短路径长为$2$。最后，通过查找与$v_2$和$v_4$相邻的顶点我们找到$v_5$和$v_7$最短路径长为$3$。此时所有的顶点都已查找完毕。这种搜索图的方法成为*广度优先搜索*。该方法按层处理顶点：距开始点最近的那些顶点首先被处理，而最远的那些顶点最后被处理，这很像对树的层序遍历。

为了实现该算法，我们可以使用一个队列。在算法开始的时候，队列只含有距离为$0$的顶点，当我们添加距离为$1$的那些邻接顶点时，将它们自队尾入队，这样就保证它们直到为$0$的顶点被处理后才能被处理。在距离为$1$的最后一个顶点出队并被处理后，队列中只含有距离为$2$的顶点，以此类推，该过程将不断进行下去。

在使用邻接表的情况下，该算法的运行时间是$O(|E|+|V|)$

### 代码位置

---

SourceCode/Graph/ShortestPaths/UnweightedShortestPaths.ts
