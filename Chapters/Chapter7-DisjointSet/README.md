<!-- @format -->

## 不相交集

### 等价关系

---

对于每一对元素$(a,b)$，$a,b \in S$，$aRb$为$True$或$False$，则在集合$S$上定义关系$R$。如果$aRb$是$True$，那么$a$与$b$就有关系。

等价关系是满足下列三个性质的关系$R$:

1. (自反性)对于所有的$a \in S$，$aRa$。
2. (对称性)$aRb$且$bRa成立$。
3. (传递性)若$aRb$且$bRc$，则$aRc$。

举两个例子来说，小于等于($\leq$)不是等价关系，因为它不是对称的，即如果$a \leq b$成立则$b \leq a$不一定成立。而电路的连通性是一个等价关系。

一个元素$a \in S$的等价类是$S$的一个子集，它包含所有与$a$有关系的元素。等价类将$S$划分成若干个子集：$S$的每一个成员恰好出现在一个等价类中。为确定$aRb$是否为$True$，只需验证$a$和$b$是否都在同一个等价类中。

如果集合$S$中的任意一个元素$v$，都能单独构成一个等价类，即集合$S$被划分为$N$($N$为集合$S$的大小)个子集，对于任意的两个子集$S_i$和$S_j$，都有$S_i \bigcap S_j= \varnothing$。那么对于集合$S$中的任意两个元素$a$和$b$，都有$aRb=False$。

此时，对于集合$S$中的元素有两种操作可以进行。第一种查找操作，它返回包含给定元素的等价类的名字。第二种运算是求并操作，如果要添加关系$aRb$，那么首先通过对$a$和$b$执行查找操作来检验它们是否在同一个等价类中。如果它们不在同一类中，那么就把含有$a$和$b$的两个等价类合并成一个新的等价类。从集合的角度来说，求并的结果是建立一个新的集合$S_k=S_1 \bigcup S_2$。

### 基本数据结构

---

由于$Find$操作返回的是包含给定元素的等价类的名字，当两个元素$a$和$b$属于相同的集合时，$Find(a)==Find(b)$。因此可以使用树来表示每一个集合，因为树上的每一个元素都有相同的根。这样，该根就可以用来命名所在的集合。在开始时每个集合都只含有一个元素。集合的名字由根处的节点给出，由于只需要父节点的名字，因此我们可以用数组来实现这个树：数组的每个成员$P[i]$表示元素$i$的父节点，如果$i$是根，那么$P[i]=0$。在图 8-1 的森林中，对于$1 \leq i \leq 8,P[i]=0$。

<image src="../../Assets/Images/ch8/8-1.png"/>

图 8-1 八个元素，最初是在八个不同的集合上

#### 求并操作

两个集合的$Union$操作，通过将一个集合的根节点指向另一个集合的根节点所在数组的下标，如下图所示。

<image src="../../Assets/Images/ch8/8-2.png"/>

图 8-2 在$Union(5,6)之后$

<image src="../../Assets/Images/ch8/8-3.png"/>

图 8-3 在$Union(7,8)之后$

<image src="../../Assets/Images/ch8/8-4.png"/>

图 8-4 在$Union(5,7)之后$

#### 查找操作

对元素$X$的$Find$操作是通过递归地查找元素的父节点，直到该父节点就是包含$X$的集合的根节点结束。执行这次操作花费的时间与表示$X$的节点的深度成正比。

### 灵巧求并算法

---

上面描述的$Union$算法通过使第二棵树成为第一棵树的子树而完成合并，但这种方法是相当随意的，在最坏情况下$Union$方法建立的是一棵深度为$N-1$的树。如果我们按树的高度求并，使得高度较小的树成为高度较大的树的子树，那么任何节点的高度均不会超过$\log N$。因为节点初始位于深度为$0$的位置，当它的深度随着一次$Union$操作而增加的时候，则该节点被置于至少是它以前所在树两倍大的一棵树上，因此它的深度最多可以增加$\log N$次。只有当两个高度相同的树求并时树的高度才增加。

为了实现这种方法，需要记住每一棵树的高度。我们可以让每个根节点在数组中的值是该树的高度的负值。这样的话，初始时树的数组就全都为$-1$。在图 8-4 所示的求并结果就变为图 8-5 所示。

<image src="../../Assets/Images/ch8/8-5.png"/>

图 8-5 按高度求并

### 路径压缩

---

从集合$S$中查找节点$X$，路径压缩的效果是，从$X$到根节点的路径上的每一个节点的父节点变成根节点。图 8-6 展示

<image src="../../Assets/Images/ch8/8-6.png"/>

图 8-6 路径压缩之前

路径压缩的关键在于对从节点$X$到通向根节点路径上的每一个节点递归地将节点的父节点设置为根节点。

<image src="../../Assets/Images/ch8/8-7.png"/>

图 8-7 执行$Find(8)$之后路径压缩的效果

### 代码位置

---

[SourceCode/DisjointSet/DisjoinSet.ts](../../SourceCode/DisjointSet/DisjointSet.ts)
