<!-- @format -->

## 最小生成树

一个无向图$G$的最小生成树就是由该图的那些连接$G$的所有顶点的边构成的树，且其总价值最低。最小生成树存在当且仅当$G$是连通的。

<image src="../../../Assets/Images/ch9/9-4-1.png" />
图 9-4-1 图$G$和它的最小生成树

在最小生成树中，边的条数为$|V|-1$。最小生成树是一棵树，因为它无圈；因为最小生成树包含每一个顶点，所以它是生成树。此外，最小生成树是包含图的所有顶点的最小的树。

对于任一生成树$T$，如果将一条不属于$T$的边$e$添加进来，则产生一个圈。如果从该圈中除去任意一条边，则又恢复生成树的特性。如果边$e$的值比除去的边的值低，那么新的生成树的值就比原生成树的值低。如果在建立生成树时所添加的边在所有避免成圈的边中值最小，那么最后得到的生成树的值不能再改进，因为任意一条替代的边的值都大于等于已经存在于该生成树中的一条边的值。对于最小生成树，这种贪欲是成立的，下面介绍两种算法，它们的区别在于最小值的边的选取策略不同。

### Prim 算法

---

计算最小生成树的一种方法是使其连续地一步步长成。在每一步，都要把一个节点当作根并往上加边，这样也就把相关联的顶点加到增长中的树上。

算法在每一阶段都可以通过选择边$(u,v)$，使得$(u,v)$的值是所有$u$在树上但$v$不再树上的边的值中的最小者，从而找出一个新的顶点并把它添加到这棵树中。图 9-4-2 描述算法如何从$v_1$开始构建最小生成树。

<image src="../../../Assets/Images/ch9/9-4-2.png">

图 9-4-2 在每一步之后的 Prim 算法

Prim 算法基本上和求最短路径的 Dijkstra 算法一样。不用堆时的运行时间是$O(|V|^2)$，它对于稠密的图来说是最优的，使用二叉堆的运行时间是$O(|E|\log|V|)$，对于稀疏的图它是一个好的界。

### Kruskal 算法

---

第二种贪婪策略是连续地按照最小地权选边，并且当所选的边不产生圈时就把它作为取定的边。

形式上，Kruskal 算法是在处理一个森林-树的集合。开始的时候，存在$|V|$棵单节点树，而且添加一边则将两棵树合并成一棵树。当算法终止的时候，就只有一棵树了，这棵树就是最小生成树。图 9-4-3 显示边被添加到森林中的顺序。

<image src="../../../Assets/Images/ch9/9-4-3.png"/>

图 9-4-3 在每一步之后的 Kruskal 算法

我们用到的一个恒定的事实是，在算法实施的任一时刻，两个顶点属于同一个集合当且仅当它们在当前的生成森林中连通。因此，每个顶点最初是在它自己的集合中。如果$u$和$v$在一个集合中，那么连接它们的边就要放弃。因为它们已经连通了，因此再添加边$(u,v)$会形成一个圈。如果这两个顶点不再一个集合中，则将该边加入，并对包含顶点$u$和$v$的这两个集合实施一次合并。容易看到，这将保持集合不变性，因为一旦边$(u,v)$添加到生成森林中，若$w$连通到$u$而$x$连通到$v$，则$x$和$w$必然是连通的，因此属于相同的集合。

用线性时间建立一个堆，此时$DeleteMin$将使得边序依次得到测试。典型情况下，在算法终止钱只有一小部分边需要测试，尽管测试所有的边的情况也是有可能的。

该算法的最坏情形运行时间为$O(|E|\log|E|)$，由于$|E|=O(|V|^2)$，因此这个运行时间实际上是$O(|E|\log|V|)$。

### 代码位置

---

[SourceCode/Graph/MinimumSpanningTree/Prim.ts](../../../SourceCode/Graph/MinimumSpanningTree/Prim.ts)

[SourceCode/Graph/MinimumSpanningTree/Kruskal.ts](../../../SourceCode/Graph/MinimumSpanningTree/Kruskal.ts)
