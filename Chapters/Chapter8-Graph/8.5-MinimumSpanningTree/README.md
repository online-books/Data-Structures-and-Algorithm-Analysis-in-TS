<!-- @format -->

## 最小生成树

一个无向图$G$的最小生成树就是由该图的那些连接$G$的所有顶点的边构成的树，且其总值最低。只有当$G$是连通的时最小生成树才会存在。

<image src="../../../Assets/Images/ch8/8-16.png" />

图 8-16 图$G$和它的最小生成树

在最小生成树中，边的条数为$|V|-1$。对于任一生成树$T$，如果将一条不属于$T$的边$e$添加进来，则产生一个圈。如果从该圈中去掉任意一条边，则又恢复生成树的特性。如果边$e$的值比去掉的边的值低，那么新的生成树的值就比原生成树的值低。如果在建立生成树时所添加的边在所有避免成圈的边中值最小，那么最后得到的生成树的值就是最小的，因为任意一条替代的边的值都大于等于已经存在于该生成树中的一条边的值。对于最小生成树，这种贪婪算法是可行的。

### Prim 算法

---

第一种贪婪策略是使生成树连续地一步步长成。在初始阶段，通过遍历图$G$来找到含有最小值的边$(u,v)$，把顶点$u$作为生成树的根节点，并把顶点$u$插入到一个空的二叉堆$H$中。在接下来的循环阶段，每次对$H$执行$DeleteMin$操作得到顶点$v$，将所有与$v$邻接的顶点及它们的边值插入到堆$H$中,并从中选取边值最小的顶点$w$将其添加到生成树上。重复该步骤直到所有的顶点都添加完毕，算法终止。

<image src="../../../Assets/Images/ch8/8-17.png">

图 8-17 从$v_1$开始构建最小生成树

Prim 算法基本上和求最短路径的 Dijkstra 算法一样。对于稠密的图来说，不用堆时的运行时间是$O(|V|^2)$。稀疏的图来说，使用二叉堆的运行时间是$O(|E|\log|V|)$。

### Kruskal 算法

---

第二种贪婪策略是连续地按照最小地权选边，并且当所选的边不产生圈时就把它作为取定的边。

在形式上，Kruskal 算法是在处理一个森林-树的集合。设图$G$有$N$个顶点，每个节点都是一个集合，这$N$个集合就表示$N$棵单节点的树。构建生成树的过程就是不断地选取两个集合将它们合并成一个。当算法终止时就只有一棵树，这棵树就是最小生成树。

<image src="../../../Assets/Images/ch8/8-18.png"/>

图 8-18 在每一步之后的 Kruskal 算法

由于图$G$中的$N$个顶点划分成了$N$个集合，因此我们可以将这$N$个顶点放入不相交集中，用$Find$和$Union$操作来执行树的合并。在算法的初始阶段，将图$G$的每条边及它的值插入到二叉堆$H$中。在循环阶段每次对$H$执行$DeleteMin$操作，得到一条最小值的边$(u,v)$。如果顶点$u$和$v$不在同一个集合中，那么就对包含顶点$u$和$v$的这两个集合执行$Union$操作，否则就说明这两个顶点已经在同一棵树上了。

该算法的最坏情形运行时间为$O(|E| \cdot \log|E|)$，由于$|E|=O(|V|^2)$，因此这个运行时间实际上是$O(|E|\log|V|)$。

### 代码位置

---

[SourceCode/Graph/MinimumSpanningTree/Prim.ts](../../../SourceCode/Graph/MinimumSpanningTree/Prim.ts)

[SourceCode/Graph/MinimumSpanningTree/Kruskal.ts](../../../SourceCode/Graph/MinimumSpanningTree/Kruskal.ts)
