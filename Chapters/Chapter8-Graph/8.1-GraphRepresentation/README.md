<!-- @format -->

## 图论算法

### 若干定义

---

一个图$G=(V,E)$由顶点集$V$和边集$E$组成。每一条边就是一个点对$(v,w)$，其中$v,w \in V$。如果点对是有序的，那么图就叫做**有向图**。顶点$v$和$w$邻接当且仅当$(v,w) \in E$。在一个具有边$(v,w)$从而具有边$(w,v)$的无向图中，$v$和$w$邻接且$w$和$v$也邻接。有时候边还具有第三种成分，叫**权**或**值**。

图中的一条路径是一个顶点序列$w_1,w_2,w_3,...,w_N$，使得$(w_i,w_{i+1}) \in E,1 \leq i \leq N$。这样一条路径的长是该路径的边数，等于$N-1$。如果图含有一条从一个顶点到它自身的边$(v,v)$，那么路径$(v,v)$叫做**环**。一条简单的路径是这样一条路径：其上的所有顶点都是互异的，但第一个顶点和最后一个顶点可能相同。

有向图中的**圈**是满足$w_1=w_N$且长至少为 $1$ 的一条路径；如果该路径是简单路径，那么这个圈就是简单圈。对于无向图，我们要求边是互异的。如果一个有向图没有圈，则称其为无圈图。

如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是**连通的**。具有这样性质的有向图是**强连通的**。如果一个有向图不是强连通的，但是它的**基础图**，即其边上去掉方向所形成的图，是连通的，那么该有向图称为是**弱连通的**。**完全图**是其每一个顶点对之间都存在一条边的图。

### 图的表示

---

我们将考虑有向图（无向图可类似表示）。

现在假设可以从$1$ 开始对顶点编号。图 9-1 中所示的图有 $7$ 个顶点和 $12$ 条边。

<image src="../../Assets/Images/ch9/9-0-1.png"/>

图 9-1 一个有向图

表示图的一种简单方法是使用一个二维数组，成为*邻接矩阵*表示法。对于每条边$(v,w)$，我们置$A[v][w]=1$，否则，数组的元素就是$0$。如果边有一个权，那么我们可以置$A[v][w]$等于该权。虽然这么表示的优点是非常简单，但它的需求空间是$\Theta(\mid V \mid^2)$。如果图的边不是很多，那么这种表示的代价就太大了。如图是**稠密**的，即$\mid E \mid = \Theta(\mid V \mid^2)$，则邻接矩阵是合适的表示方法。

如果图不是稠密的或者说图是稀疏的，则更好的解决方法是使用**邻接表**表示。对每一个顶点，我们使用一个表存放所有邻接的顶点。此时的空间需求是$O(\mid E \mid+\mid V \mid)$。图 9-2 最左边的结构只是头单元的数组。这种表示方法从图 9-2 可以清楚地看出。如果边有权，那么这个附加的信息也可以存储在单元中。

<image src="../../Assets/Images/ch9/9-0-2.png"/>

图 9-2 图的邻接表表示法

邻接表是表示图的标准方法。无向图可以类似地表示：每条边$(v,w)$出现在两个表中，因此空间的使用基本上是双倍的。

在大部分实际应用中顶点都有名字而不是数字，这些名字是未知的。由于我们不能通过未知名字作为一个数组的索引，因此我们必须提供从名字到数字的映射。完成这项工作最容易的方法就是使用散列表，在散列表中我们对每个顶点存储一个名字以及一个范围在$1~\mid V \mid$之间的内部编号。这些编号在图被读入的时候指定。指定的第一个数是$1$。在每条边被读入时，我们检查是否它的两个顶点都已经指定了一个整数，检查的方法是看是否顶点在散列表中。如果在，那我们就使用这个内部编号，否则，我们将下一个可用的编号分配给该顶点并把该顶点的名字和对应的编号插入到散列表中。

经过这样的变换，所有的图论算法都将只使用内部编号。由于最终我们还是要输出顶点的名字而不是这些内部编号，因此对于每一个内部编号我们必须记录相应的顶点名字。一种记录方法是使用字符串数组。如果顶点名字长，那就要花费大量的空间，因为顶点的名字要存两次。

### 代码位置

---

SourceCode/Graph/Graph.ts
