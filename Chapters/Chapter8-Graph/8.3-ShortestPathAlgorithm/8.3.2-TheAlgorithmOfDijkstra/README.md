<!-- @format -->

## Dijkstra 算法

在有向赋权图中，解决单源最短路径的一般方法叫*Dijkstra*算法。这个算法是贪婪算法最好的例子。贪婪算法一般地分阶段求解一个问题，在每个阶段它都把当前出现的当作是最好的去处理。

### 算法描述

Dijkstra 算法就像无权最短路径算法一样按阶段进行。具体的步骤如下：

1.  首先，用一个数组存储每个节点到起始节点$s$的临时距离，$s$到其自身的距离为$0$，其他节点到$s$的距离为$\infty$。
2.  将起始节点$s$和其临时距离$d_s=0$插入到二叉堆$h$中。
3.  只要二叉堆$h$不为空，就从$h$中执行$DeleteMin$操作，得到临时距离为最小的节点$v$。如果节点$v$为已知的，则继续执行该步骤，直到二叉堆为空。
4.  如果节点$v$为未知的，则将该节点标为已知。假设顶点$w$是$v$的邻接顶点，$c_w$是$v$与$w$之间的权重值，若存储临时距离的数组中$d_w<d_v+c_w$，则置$d_w=d_v+c_w$,并将节点$w$及$d_w$插入到二叉堆中，继续执行步骤 2。

下面以图 8-7 中的图为例说明。

<image height="240" src="../../../../Assets/Images/ch8/8-4.png" />

假设开始节点$s$是$v_1$。第一个选择的顶点是$v_1$，距离值为$0$，将该顶点标记为已知。$v_1$的邻接顶点是$v_2$和$v_4$，分别将它们的距离值更新为$d_{v_2}=d_{v_1}+2=0+1=2,d_{v_4}=d_{v_1}+1=0+1=1$。

下一步，在$v_1$的邻接顶点中选取$v_4$标记为已知。顶点$v_3,v_5,v_6,v_7$是$v_4$邻接的顶点，更新它们到$s$的距离值为$d_{v_3}=d_{v_4}+2=3,d_{v_5}=d_{v_4}+2=3,d_{v_6}=d_{v_4}+8=9,d_{v_7}=d_{v_4}+4=5$。

接着选择$v_2$。$v_4$是其邻接的顶点，但已经是已知的，因此无需操作。$v_5$是邻接的点但不做调整，因为经过$v_2$的距离值为$2+10=12$，而长为$3$
的路径是已知的。

下一个被选取的点是$v_5$，其距离值为$3$。$v_7$是其唯一的邻接点，但不需要调整。然后选取$v_3$，对$v_6$的距离更新为$3+5=8$。

再下一个选取的顶点是$v_7$。$v_6$的距离值更新为$5+1=6$。

最后，我们选择$v_6$。

### 运行时间分析

在每次对与$s$邻接的顶点$w$执行操作时，将顶点$w$和新的$d_w$值插入到堆中。这样，在堆中的每个顶点就有可能有多余一个的表示。这种方法虽然简单但堆的大小有可能达到$|E|$这么大。由于$|E| \leq |V|^2$，因此$\log|E| \leq 2\log|V|$，所以我们仍然得到一个$O(|E|\log|V|)$的算法。

### 代码位置

---

[SourceCode/Graph/ShortestPaths/TheAlgorithmOfDijkstra.ts](../../../../SourceCode/Graph/ShortestPaths/TheAlgorithmOfDijkstra.ts)
