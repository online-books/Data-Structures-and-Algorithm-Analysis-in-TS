<!-- @format -->
<!-- @format -->

## 最短路径算法

这一节我们考察各种最短路径问题。输入是一个赋权图：与每条边$(v_i,v_j)$相联系的是穿越该弧的代价。一条路径$v_1,v_2,...,v_N$的值是$\sum_{i=1}^{N-1}c_{i,i+1}$叫做赋权路径长(weighted path length)。而无权路径长只是路径上的边数，即$N-1$。

### 单源最短路径问题

---

给定一个赋权图$G=(V,E)$和一个特定顶点$s$作为输入，找出从$s$到$G$中每一个其他顶点的最短赋权路径。

例如，在图 9-2-1 中，从$v_1$到$v_2$的最短赋权路径的值为$6$。它是从$v_1$到$v_4$到$v_7$的再到$v_6$的路径。在这两个顶点间的最短无权路径长为$2$。

<image  src="../../../Assets/Images/ch9/9-2-1.png"/>

图 9-2-1 有向图$G$

前面的例子中的图是没有负值的边。图 9-2-2 的图指出负边的问题可能产生。从$v_5$到$v_4$的路径的权重为$1$，但是通过下面的循环$v_5,v_4,v_2,v_5,v_4$存在一条最短路径，它的值是$-5$。这条路径仍然不是最短的，因为我们可以在循环中滞留任意长。因此，两个顶点间的最短路径问题是不确定的。这个循环叫做负值圈(negative-cost cycle)。当它出现在图中时，最短路径问题就是不确定的。

<image  src="../../../Assets/Images/ch9/9-2-2.png"/>

图 9-2-2 带有负值圈的有向图

## 无权最短路径

无权最短路径是赋权最短路径的特殊情形，因为我们可以为所有的边都赋权为$1$。 图 9-2-3 表示一个无权的图

<image src="../../../../Assets/Images/ch9/9-2-3.png">

图 9-2-3 一个无权有向图 G

假设我们要找出上图中$v_3$到所有其他顶点的最短路径长。首先找到所有与$v_3$距离为$1$的顶点。这些顶点可以通过查找与$v_3$邻接的那些顶点找到，得到$v_1$和$v_6$的最短路径长为$1$。然后，可以开始找出那些从$v_3$出发最短路径为$2$的顶点，即找出所有邻接到$v_1$和$v_6$的顶点，得到$v_2$和$v_4$的最短路径长为$2$。最后，通过查找与$v_2$和$v_4$相邻的顶点我们找到$v_5$和$v_7$最短路径长为$3$。此时所有的顶点都已查找完毕。这种搜索图的方法成为*广度优先搜索*。该方法按层处理顶点：距开始点最近的那些顶点首先被处理，而最远的那些顶点最后被处理，这很像对树的层序遍历。

为了实现该算法，我们可以使用一个队列。在算法开始的时候，队列只含有距离为$0$的顶点，当我们添加距离为$1$的那些邻接顶点时，将它们自队尾入队，这样就保证它们直到为$0$的顶点被处理后才能被处理。在距离为$1$的最后一个顶点出队并被处理后，队列中只含有距离为$2$的顶点，以此类推，该过程将不断进行下去。

在使用邻接表的情况下，该算法的运行时间是$O(|E|+|V|)$

### 代码位置

---

SourceCode/Graph/ShortestPaths/UnweightedShortestPaths.ts
