<!-- @format -->

## 查找强分支

通过执行一次深度优先搜索，我们可以检测一个图是否是强连通的，如果它不是强连通的，那么我们实际上可以得到顶点的一些子集，它们到其自身是强连通的。

<image height="240" src="../../../Assets/Images/ch8/8-26.png" />

首先，在输入的图$G$上执行一次深度优先搜索。通过对深度优先生成森林的后序遍历将$G$的顶点编号，然后再把$G$的所有的边反向，形成$G_r$。如图 8-27 所示。

<image  height="240" src="../../../Assets/Images/ch8/8-27.png" />

该算法通过对$G_r$执行一次深度优先搜索而完成，总是在编号最高的顶点开始一次新的深度优先搜索。于是，我们在顶点$G$开始对$G_r$的深度优先搜索，该顶点不通向任何顶点，因此下一次搜索在点$H$开始。这次调用访问$I$和$J$。下一次调用在$B$点开始并访问$A$、$C$和$F$。此后的调用是$Dfs(D)$即最终调用$Dfs(E)$。结果得到的强分支为$\{ G\}$,$\{H,I,J\}$,$\{B,A,C,F\}$,$\{D\}$,$\{E\}$。

这个算法为什么会成立呢？如果两个顶点$v$和$w$都在同一个强连通分支中，那么在原图$G$中就存在从$v$到$w$和从$w$到$v$的路径。等价地，如果$x$是$G_r$包含$v$的深度优先生成树的根，那么存在一条从$x$到$v$和从$v$到$x$的路径。对$w$应用相同的推理则得到一条从$x$到$w$和从$w$到$x$的路径。这些路径则意味着经过$x$有从$v$到$w$和从$w$到$v$的路径。

由于$v$是$x$在$G_r$的深度优先生成树中的一个后裔，因此存在$G_r$中一条从$x$到$v$的路径，从而存在$G$中一条从$v$到$x$的路径。此外，由于$x$是根节点，因此$x$从第一次深度优先搜索得到更高的后续编号。于是，在第一次深度优先搜索期间所有处理$v$的工作都在$x$的工作前完成。既然存在一条从$v$到$x$的路径，因此$v$必然是$x$在$G$的生成树中的一个后裔，否则$v$将在$x$之后结束。这意味着$G$中从$x$到$v$有一条路径，因此算法成立。

### 代码位置

---

[SourceCode/Graph/StrongComponnent.ts](../../../../SourceCode/Graph/StrongComponent.ts)
