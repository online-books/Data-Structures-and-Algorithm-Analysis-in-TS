<!-- @format -->

## 欧拉回路

如果要在无向图中找出一条从起点$v$出发到终点$w$的路径，使得该路径对图的每条边恰好访问一次，这条路径叫做*欧拉路径*。如果起点和终点相同，那么就必须在图中找到一个圈，该圈恰好经过每条边一次，这条路径就是*欧拉回路*。

任何连通图有欧拉回路的充分必要条件就是所有顶点的度均为偶数。这是因为，在欧拉回路中，一个顶点有边进入，则必然有边离开。如果任一顶点$v$的入度为奇数，那么最后会到达这样一种情况：即只有一条进入$v$的边尚未访问到，若沿该边进入$v$点，那么我们只能停留在顶点$v$，不可能再出来。如果恰好有两个顶点的度是奇数，那么当我们从一个奇数度的顶点出发最后终止在另一个奇数度的顶点时，仍然有可能得到一个欧拉路径。如果奇数度的顶点多余两个，那么欧拉路径也不可能存在。

我们可以通过执行一次深度优先搜索以线性时间检测这个充分必要条件。算法的主要问题在于，我们可能只访问了图的一部分而提前返回到起点。如果从起点出发的所有边均已用完，那么图中就会有的部分遍历不到。最容易的补救方法是找出有尚未访问的边的路径上的第一个顶点，并执行另外一次深度优先搜索，然后将得到的这个新的回路拼接到原来的回路上，继续该过程直到所有的边都被遍历为止。

我们以图 8-22 中的图来举例说明。

<image height="240" src="../../../Assets/Images/ch8/8-22.png"/>

图 8-22 具有欧拉回路的图

这个图有一个欧拉回路。设从顶点 E 开始，依次遍历顶点 E、D、J、E，此时连接到顶点 E 的边都已遍历完毕，但图的大部分还没有遍历到。如图 8-23 所示。

<image height="240" src="../../../Assets/Images/ch8/8-23.png"/>

图 8-23 遍历 E、D、J、E 后剩下的图

此时，我们从顶点 D 继续进行。又得到路径 D、A、C、G、D、K、J、G、I、C、D。如果我们把这条路径拼接到前面的路径 E、D、J、E 上，那么我们就得到一条新路径 E、D、A、C、G、D、K、J、G、I、C、D、J、E。

<image height="240" src="../../../Assets/Images/ch8/8-24.png"/>

图 8-24 遍历 E、D、A、C、G、D、K、J、G、I、C、D、J、E 后剩下的图

此后，剩下的图如图 8-25 所示。在该路径上，算法找到回路 C、B、H、I、F、C。当把它拼接到当前的路径中，我们得到回路 E、D、A、C、B、H、I、F、G、D、K、J、G、I、C、D、J、E。

<image height="240" src="../../../Assets/Images/ch8/8-25.png"/>

图 8-25 遍历 E、D、A、C、B、H、I、F、G、D、K、J、G、I、C、D、J、E 后剩下的图

最后，算法找到回路 I、L、J、I。把它拼接到当前的路径中能够得到回路 E、D、A、C、B、H、I、F、G、D、K、J、G、I、L、J、C、D、J、E。当所有的边都被遍历时，算法终止，我们得到一个欧拉回路。

需要注意的是，当拼接一个路径时，必须从拼接点开始搜索新顶点，从这个新顶点进行下一轮深度优先搜索。这将保证在整个算法期间对顶点搜索阶段进行的全部工作了为$O(|E|)$，算法的运行时间为$O(|E|+|V|)$。

### 代码位置

---

[SourceCode/Grap/EulerPath.ts](../../../SourceCode/Graph/EulerPath.ts)
