<!-- @format -->

## 欧拉回路

考虑图 9-5-4 中的三个图。用笔重画这些图，每条线恰好画一次，在画图的过程中笔不要从图上离开。作为一个附加的问题，要在结束画图时，使笔能回到开始画图时的起点上。

<image src="../../../../Assets/Images/ch9/9-5-4.png"/>

图 9-5-4 三幅图画

第一个图仅当起点在左下角或右下角时可以画出，而且不可能结束在起点处。第二个图容易画出，它的起点和终点相同。第三个图在限制条件下无法画出。

将问题转化为图论问题后，我们必须在图中找出一条路径，使得该路径对图的每条边恰好访问一次。如果要解决“附加问题”，那么我们就必须找到一个圈，该圈恰好经过每条边一次。

能够做的第一个观察是，其终点必须终止在起点上的欧拉回路只有当图是连通的且每个顶点的度是偶数时才有可能存在。这是因为，在欧拉回路中，一个顶点有边进入，则必然有边离开。如果任一顶点$v$的入度为奇数，那么实际上我们早晚会达到这样一种地步，即只有一条进入$v$的边尚未访问到，若沿该边进入$v$点，那么我们只能停留在顶点$v$，不可能再出来。如果恰好有两个顶点的度是奇数，那么当我们从一个奇数度的顶点出发最后终止在另一个奇数度的顶点时，仍然有可能得到一个欧拉环游。欧拉环游是必须访问图的每一边但最后不一定必须回到起点的路径。如果奇数度的顶点多余两个，那么欧拉环游也不可能存在。

任何连通图有欧拉回路的充分必要条件就是所有顶点的度均为偶数。

由于我们可以用线性时间检测这个充分必要条件，因此可以假设我们知道存在一条欧拉回路。此时，基本算法就是执行一次深度优先搜索。算法的主要问题在于，我们可能只访问了图的一部分而提前返回到起点。如果从起点出发的所有边均已用完，那么图中就会有的部分遍历不到。最容易的补救方法是找出有尚未访问的边的路径上的第一个顶点，并执行另外一次深度优先搜索。这将给出另外一个回路，把它拼接到原来的回路上。继续该过程知道所有的边都被遍历为止。

作为例子，考虑图 9-5-5 中的图。

<image src="../../../../Assets/Images/ch9/9-5-5.png"/>

图 9-5-5 具有欧拉回路的图

这个图有一个欧拉回路。设从顶点 5 开始，我们遍历 5、4、10、5，此时已无路可走，图的大部分还没有遍历到。情况如图 9-5-6 所示。

<image src="../../../../Assets/Images/ch9/9-5-6.png"/>

图 9-5-6 遍历 5、4、10、5 后剩下的图

此时，我们从顶点 4 继续进行。结果，又得到路径 4、1、3、7、4、11、10、7、9、3、4。如果我们把这条路径拼接到前面的路径 5、4、10、5 上，那么我们就得到一条新路径 5、4、1、3、7、4、11、10、7、9、3、4、10、5。

<image src="../../../../Assets/Images/ch9/9-5-7.png"/>

图 9-5-7 遍历 5、4、1、3、7、4、11、10、7、9、3、4、10、5 后剩下的图

此后，剩下的图表示在图 9-5-8 中。在该路径上，算法找到回路 3、2、8、9、6、3。当把它拼接到当前的路径中，我们得到回路 5、4、1、3、2、8、9、6、3、7、4、11、10、7、9、3、4、10、5。

<image src="../../../../Assets/Images/ch9/9-5-8.png"/>

图 9-5-8 遍历 5、4、1、3、2、8、9、6、3、7、4、11、10、7、9、3、4、10、5 后剩下的图

最后，算法找到回路 9、12、10、9。把它拼接到当前的路径中能够得到回路 5、4、1、3、2、8、9、12、10、9、6、3、7、4、11、10、7、9、3、4、10、5。当所有的边都被遍历时，算法终止，我们得到一个欧拉回路。

需要注意的是，当拼接一个路径时，必须从拼接点开始搜索新顶点，从这个新顶点进行下一轮深度优先搜索。这将保证在整个算法期间对顶点搜索阶段进行的全部工作了为$O(|E|)$，算法的运行时间为$O(|E|+|V|)$。

### 代码位置

---

[SourceCode/Grap/EulerPath.ts](../../../../SourceCode/Graph/EulerPath.ts)
