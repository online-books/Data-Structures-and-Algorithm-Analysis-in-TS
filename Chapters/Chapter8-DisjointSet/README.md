<!-- @format -->

## 不相交集

### 等价关系

---

对于每一对元素$(a,b)$，$a,b \in S$，$aRb$或者为$true$或者为$false$，则成在集合$S$上定义关系$R$。如果$aRb$是$true$，那么我们说$a$与$b$有关系。

等价关系是满足下列三个性质的关系$R$:

1. (自反性)对于所有的$a \in S$，$aRa$。
2. (对称性)$aRb$当且仅当$bRa$。
3. (传递性)若$aRb$且$bRc$，则$aRc$。

举两个例子，关系$\leq$不是等价关系，为它不是对称的，即从$a \leq b$不能推出$b \leq a$。而电气连通性是一个等价关系，其中所有的连接都是通过金属导线完成的。

一个元素$a \in S$的等价类是$S$的一个子集，它包含所有与$a$有关系的元素。等价类形成对$S$的一个划分：$S$的每一个成员恰好出现在一个等价类中。为确定是否$a ~ b$，我们只需验证$a$和$b$是否都在同一个等价类中。

输入数据最初是$N$个集合的类，每个集合都含有一个元素。初始的描述是所有的关系均为$false$。每个集合都有一个不同的元素，从而$S_1 \bigcap S_2= \varnothing$，这使得这些集合不相交。

此时，有两种运算允许进行。第一种运算是$Find$，它返回包含给定元素的集合的名字。第二种运算是添加关系，如果我们想要添加关系$a ~ b$，那我们首先要看$a$和$b$是否已经有关系。这可以通过对$a$和$b$执行$Find$并检验它们是否在同一个等价类中来完成。如果它们不在同一类中，那我们使用求并运算$Union$，这种运算把含有$a$和$b$的两个等价类合并成一个新的等价类。从集合的观点来看，$U$的结果是建立一个新的集合$S_k=S_1 \bigcup S_2$。

### 基本数据结构

---

记住，我们的问题不要求$Find$操作返回任何特定的名字，而只是要求当且仅当两个元素属于相同的集合时，作用在这两个元素的$Find$返回相同的名字。一种想法是可以使用树来表示每一个集合，因为树上的每一个元素都有相同的根。这样，该跟就可以用来命名所在的集合。我们用树来表示每一个集合，开始时每个集合都含有一个元素。集合的名字由根处的节点给出，由于只需要父节点的名字，因此我们可以假设树被存储在一个数组中：数组的每个成员$P[i]$表示元素$i$的父亲，如果$i$是根，那么$P[i]=0$。在图 8-1 的森林中，对于$1 \leq i \leq 8,P[i]=0$。

<image src="../../Images/ch8/8-1.png"/>

图 8-1 八个元素，最初是在八个不同的集合上

为了执行两个集合的$Union$运算，我们使一个节点的根指针指向另一棵树的根节点。这种操作花费常数时间。图 8-2、8-3 和 8-4 分别表示在$Union(5,6)$，$Union(7,8)$，$Union(5,7)$之后的森林。

<image src="../../Images/ch8/8-2.png"/>

图 8-2 在$Union(5,6)之后$

<image src="../../Images/ch8/8-3.png"/>

图 8-3 在$Union(7,8)之后$

<image src="../../Images/ch8/8-4.png"/>

图 8-4 在$Union(5,7)之后$

对元素$X$的一次$Find$操作通过返回包含$X$的树的根而完成。执行这次操作花费的时间与表示$X$的节点的深度成正比。使用上面的$Union$方法，能够建立一棵深度为$N-1$的树，使得一次$Find$的最坏情形运行时间是$O(N)$。

### 灵巧求并算法

---

上面$Union$的执行是相当任意的，它通过使第二棵树成为第一棵树的子树而完成合并。对其进行简单改进是借助任意的方法打破现有关系，使得总让较小的树成为较大的树的子树：我们把这种方法叫做按大小求并。如果$Union$都是按照大小进行的，那么任何节点的深度均不会超过$logN$。为此，首先注意节点初始于深度为$0$的位置，当它的深度随着一次$Union$的结果而增加的时候，该节点则被置于至少是它以前所在树两倍大的一棵树上，因此它的深度最多可以增加$logN$次，而连续$M$次操作则花费$O(MlogN)$。

为了实现这种方法，我们需要记住每一棵树的大小。由于我们实际上只使用一个数组，因此可以让每个根的数组元素包含它的树的大小的负值。这样一来，初始时树的数组表示就都是$-1$了。

令一种实现方法为按高度求并，它同样保证所有的树的深度最多是\$O(logN)

### 路径压缩

---

设操作为$Find(X)$，此时路径压缩的效果是，从$X$到根的路径上的每一个节点都使它的父节点变成根。

<image src="../../Images/ch8/8-5.png"/>

图 8-5 路径压缩之前

<image src="../../Images/ch8/8-6.png"/>

图 8-6 路径压缩之后

路径压缩的实施在于使用额外的两次指针移动，节点$13$和$14$现在离根更近了一个位置，而节点$15$和$16$现在离根近了两个位置。路径压缩对基本的$Find$操作的改变是使得$S[X]$等于$Find$返回的值；这样，在集合的根被递归地找到后，$X$就直接指向它。对通向路径上的每一个节点这将递归地出现，因此实现了路径压缩。

### 代码位置

---

SourceCode/disjoint-set/DisjoinSet.ts
