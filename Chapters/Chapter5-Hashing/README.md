## 散列
散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是那些需要元素间任何排序信息的操作将不会得到有效的支持。因此诸如$FindMIn$、$FindMax$以及以线性时间将排过序的整个表进行打印的操作都是散列所不支持的。

### 散列函数
---
理想的散列结构是包含有关键字的具有固定大小的数组，每个关键字被映射到从$0$到$TableSize-1$这个范围中的某个树，并且被放到适当的单元中，这个映射就叫做散列函数。

<image src="../../Images/ch5/hash_table.png" />

图5-1 一个理想的散列表

如果输入的关键字是整数，则一般合理的方法就是直接返回"key mod TableSize"的结果，除非key碰巧具有某些不理想的性质。例如，若表的大小是$10$而关键字都已$0$为个位，则上面描述的散列函数就不是一个好的选择。而为了避免那样的情况，好的办法通常是保证表的大小是素数。当输入的关键字是随机整数时，散列函数不仅计算起来简单而且关键字的分配也很均匀。

通常，关键字是字符串，在这种情形下，一种选择方法是把字符串中字符的$ASCII$码值加起来。

``` typescript
// 一个简单的散列函数
private hash(element: string): number {
    let hashVal = 0;
    for (let i = 0, j = element.length; i < j; i++) {
        const code = element.codePointAt(i)!;
        hashVal += code;
    }
    return hashVal % this.tableSize;
}
```

剩下的主要是解决冲突问题。当一个元素被插入处另一个元素已经存在（散列值相同），那么就产生一个冲突。有两种最简单的方法可以解决这种冲突：分离链接法和开放定址法。

### 分离链接法（separate chaining）
---
分离链接法是将散列到同一个值的所有元素保留到一个表中。

<image src="../../Images/ch5/separate_chaining_hash_table.png" />

图5-2 分离链接散列表

为了在散列表上执行$Find$、$Insert$、$Delete$操作，先使用散列函数来确定要考察的链表，然后在链表上执行相应的$Find$、$Insert$、$Delete$。

### 开放定址法（open addressing hashing）
---
在开放定址散列算法系统中，如果有冲突发生，那么就要尝试选择另外的单元，直到找到空的单元为止。因为所有的数据都要装入表内，所以开放定址散列法所需要的表要比分离链接散列用表大。一般说来，对开放定址散列法来说，装填因子$\lambda$应该小于$0.5$。

#### 线性探测法

在线性探测法中，函数$F$是$i$的线性函数，典型情形是$F(i)=i$。这相当于逐个探测每个单元以查找一个空单元。

#### 平方探测法

平方探测法就是冲突函数为二次函数的探测方法，流行的选择是$F(i)=i^2$。一个重要的定理是如果表有一半是空的，并且表的大小是素数，那么总能够插入一个新的元素。哪怕表有一半多一个的位置被填满，那么插入都有可能失败。另外，表的大小是素数也非常重要，如果表的大小不是素数，那么备选单元的个数可能会锐减。

在开放定址散列表中，标准的删除操作不能施行，原因是相应的单元可能已经引起过冲突，元素绕过它存在了别处，因此开放定址散列表需要懒惰删除。


#### 双散列
最后一个解决冲突的方法是双散列。对于双散列，一种流行的选择是$F(i)=i • hash_2(X)$。 $hash_2(X)$选择的不好将是灾难性的，$hash_2$一定不要算得$0$值，另外保证所有的单元都能被探测到也很重要。诸如$hash_2(X)=R-(X \mod R)$是一个好的选择。

#### 再散列
对于使用平方探测的开放定址散列法，如果表的元素填的太满，那么操作的运行时间将开始效果过长，且$Insert$操作可能失败。此时，一种解决方法是建立另外一个大约两倍大小的表，扫描整个原始散列表，计算每个元素的新散列值并将其插入到新表中。

### 代码位置
---
SourceCode/hash-table/HashTable