## 归并排序

归并排序是以$O(NlogN)$最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。

这个算法中的基本操作是合并两个已排序的数组。因为这两个数组是已经排序的，所以若将输出放到第三个数组中时则该算法可以通过对输入数据的一趟排序来完成。基本的合并算法是取两个输入数组$A$和$B$，一个输出数组$C$，以及两个索引计数器$A_ptr,B_ptr$，它们初始置于对应数组的开始端。$A[A_ptr]$和$B[B_ptr]$中的较小者被依次拷贝到$C$中。当两个输入数组中有一个遍历完的时候，则将另一个数组中剩余部分拷贝到$C$中。

假设输入数组中有$N$个元素，首先递归地将前半部分数据和后半部分数据各自归并排序，得到排序后的两部分数据，然后使用上面描述合并算法再将这两部分合并到一起。该算法是经典的分治策略，它将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段解得的各个答案合并到一起。


### 运行时间分析

假设输入数组的大小为$N$且$N$是2的幂，从而我们总可以将它分为均为偶数的两部分。对于$N=1$，归并排序所用时间是1，否则，对于$N$个数归并排序的用时等于完成两个大小为$N/2$的递归排序所用的时间再加上合并的时间，我们能得到以下方程：

$$T(1)=1 \tag{1}$$
$$T(N)=2T(N/2)+N \tag{2}$$

用$N$去除递归关系的两边，得到：
$$\frac{T(N)}{N} =\frac{T(N/2)}{N/2}+1 \tag{3}$$
$$\frac{T(N/2)}{N/2} =\frac{T(N/4)}{N/4}+1 \tag{4}$$
$$\vdots$$
$$\frac{T(2)}{2}=\frac{T(1)}{1}+1 \tag{5}$$

将所有这些方程相加，最后的结果为：

$$\frac{T(N)}{N}=\frac{T(1)}{1}+logN \tag{6}$$

再将两边同乘以$N$,最后得到的答案是：
$$T(N)=NlogN+N=O(NlogN) \tag{7}$$

虽然归并排序的运行时间是$O(NlogN)$，但它很难用于主存排序，主要的问题在于合并两个排序的数组需要线性附加内存。

### 代码位置
---
SourceCode/sort/MergeSort.ts