## 引论

### 1 提出问题
---

#### 选择问题(selection problem)
设有一组N个数而要确定其中第k个最大值。"显而易见"的解决方法有很多。<br>
该问题的一种解法是将这N个数读进一个数组中，再通过某种排序算法，以递减顺序将数组排序，然后返回位置k伤的元素。<br>
稍微好一点的解法是可以把前k个元素读入数组并以递减的顺序将其排序，将剩下的元素再逐个读入。当新元素被读到时，如果它小于数组中的第k个元素则忽略，否则就将其放到数组中正确的位置上，同时将数组中的一个元素挤出数组。当算法中止时，位于第k个位置上的元素作为答案返回。<br>
这两种算法哪个更好？哪个算法更重要？还是两个算法都足够好？使用含一百万个元素的数组，在$k=500,000$的条件下进行模拟发现，两个算法在合理的时间内均不能结束。以后将讨论另一种算法，该算法将在一秒钟左右给出问题的解。因此虽然这两个算法都能算出结果，但它们不能被认为是好的算法，因为对于第三种算法在合理的时间内能够处理的输入数据量而言，这两种算法是完全不切实际的。<br>

在许多问题中，一个重要的观念是：**写出一个可以工作的程序并不够。如果这个程序在巨大的数据集上运行，那么运行时间变成了重要的问题**。



### 2 数学知识复习
---

#### 2.1 指数
$$
X^AX^B=X^{A+B} \tag{2.2.1}
$$
$$ 
\frac{X^A}{X^B}=X^{A-B} \tag{2.2.2}
$$
$$
(X^A)^B=X^{AB} \tag{2.2.3}
$$
$$
X^N+X^N=2X^N \not ={X^{2N}}  \tag{2.2.4}
$$
$$
2^N+2^N=2^{N+1} \tag{2.2.5}
$$

#### 2.2 对数

定义：X^A=B,当且仅当$log_XB=A$

除非有特别的说明，所有的对数都是以2为底的。

$$
log_AB= \frac{log_CB}{log_CA}(C>0) \tag{2.2.1}
$$
$$
log{AB}=logA+logB \tag{2.2.2}
$$
$$
log \frac{A}{B}=logA-logB \tag{2.2.3}
$$
$$
log(A^B)=BlogA \tag{2.2.4}
$$
$$
logX<X(X>0) \tag{2.2.5}
$$

#### 2.3 级数
$$
\sum_{i=0}^{N}2^i=2^{N+1}-1 \tag{2.3.1}
$$
$$
\sum_{i=0}^{N}A^i=\frac{A^{N+1}-1}{A-1} \tag{2.3.2}
$$

在公式2.3.2中，如果$0<A<1$,则
$$
\sum_{i=0}^{N}A^i \leq \frac{1}{1-A} \tag{2.3.3}
$$
当N趋于$\infty$时该和趋于$\frac{1}{1-A}$。
$$
\sum_{i=1}^{N}i^2=\frac{N(N+1)(N+2)}{6} \approx \frac{N^3}{3}  \tag{2.3.4}
$$
$$
\sum_{i=1}^{N}i^k \approx \frac{N^{k+1}}{|k+1|}(k \not ={-1})  \tag{2.3.5}
$$
$$
H_N=\sum_{i=1}^{N}\frac{1}{i} \approx lnN  \tag{2.3.6}
$$
公式2.3.6中，数$H_N$叫做调和数，其和叫调和和，近似式中的误差趋向于$\gamma \approx0.57721566$，这个值称为欧拉常数(Euler's constant)。


#### 2.4 模运算

如果N整除A-B，那么就说A与B模N同余，记为$A \equiv B(mod \ N)$。直观地看，这意味着无论A还是B被N去除，所得的余数都是相同的。于是$81 \equiv 61 \equiv1(mod \ 10)$。若$A \equiv B(mod \ N)$，则$A+C \equiv B+C(mod \ N)$以及$AD \equiv BD(mod \ N)$。


### 3 递归简论
---

作为一个例子，在非负整数集上定义一个函数$F$，他满足$F(0)=0$且$F(X)=2F(X-1)+X^2$。当一个函数用它自己来定义时就称为递归(recursive)。函数$F$的递归实现如下：
``` typescript
function F(x:number):number{
    // 基准情形
    if(x===0){
        return 0;
    }
    // 不断推进
    return 2*F(x-1)+x^2
}
```

#### 递归的四条基本法则
1. **基准情形。** 必须总有某些基准情形，它无需递归就能解出。
2. **不断推进。** 对于那些需要递归求解的情形，每一次递归调用都必须要使求解状况朝接近基准情形的方向推进。
3. **设计法则。** 假设所有的递归调用都能运行。
4. **合成效益法则。** 在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。


### 代码位置
SourceCode/Ch01.ts