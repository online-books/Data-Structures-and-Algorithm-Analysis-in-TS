<!-- @format -->

## 伸展树

伸展树是一种相对简单的数据结构，它保证从空树开始任意连续$M$次对树的操作最多花费$O(MlogN)$时间。

伸展树的基本想法是，当一个节点被访问后，它就要经过一系列类似 AVL 树的旋转被放到根上。如果一个节点很深，那么其路径上就存在许多的节点也相对较深，通过重新构造可以使对所有这些节点的进一步访问所花费的时间变少。因此，如果节点过深，那么重新构造应具有具有平衡这棵树的作用。

### 自顶向下伸展树

---

当一项$X$作为一片树叶被插入时，称为*展开*的一些列树的旋转使得$X$成为树的新根。展开操作也在查找期间执行，而且如果一项也没有找到，那么就要对访问路径上的最后的节点施行一次展开。一次展开树操作的摊还时间为$O(logN)$

> 摊还时间：当 M 次操作的序列的总的最坏情形运行时间为$O(MF(N))$时，它的摊还运行时间就为$O(F(N))$

在访问的任一时刻，我们都有一个当前节点$X$，它是其子树的根。树$L$把节点都存放在小于$X$的树$T$中，但不在$X$的子树中；类似地，树$R$把节点存在大于$X$的子树中，但不在$X$的子树中。初始时$X$为$T$的根，而$L$和$R$是空树。图 4-3-1 指出树的起始状态。

如果旋转是一次单旋转，那么根在 Y 的树编程中间树的新根。$X$和子树$B$连接而成为$R$中最小项的左儿子。如图 4-3-2 所示。

对于一字形情形，我们有类似的剖析。关键是在$X$和$Y$之间施行一次旋转。

之字形旋转可以进行简化，因为没有旋转要执行，$Z$不再是中间树的根，$Y$取而代之，如图 4-3-3 所示。

图 4-4-4 指出一旦执行完最后一步展开，我们将如何处理$L$、$R$和中间树以形成一棵树。

顶部向下展开算法的一个例子如图 4-4-5 所示。我们想要访问树中的 19。第一步是一个之字形旋转，我们把根在 25 的子树带到中间树的根处，并把 12 和它的左子树接到$L$上。

下一步是一个一字型旋转，15 被提高到中间树的根处，并在 20 和 25 之间进行一次旋转，所得到的子树被连接到$R$。此时查找 19 导致终止单旋转，中间树的新根为 18，而 15 和它的左子树作为$L$的最大节点的右儿子被接上。

### 代码位置

---

[SourceCode/Tree/SplayTree/SplayTree.ts](../../../SourceCode/Tree/SplayTree/SplayTree.ts)
