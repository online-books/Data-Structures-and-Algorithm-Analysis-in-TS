<!-- @format -->

## AVL 树

AVL(Adelson-Velskii 和 Landis)树是带有平衡条件的二叉查找树。这个平衡条件是其每个节点的左子树和右子树的高度最多差 1 的二叉查找树（空树的高度定义为$-1$）。

<image  height="240" src="../../../Assets/Images/ch4/4-8.png">

图 4-8 两棵二叉查找树，只有左边的数是 AVL 树，因为节点(8)的高度为$0$，而节点(2)的高度为$2$。

在高度为$h$的 AVL 树中，最少节点数$S(h)=S(h-1)+S(h-2)+1$。对于$h=0$，$S(h)=1$；$h=1$，$S(h)=2$。由此可以看出函数$S(h)$与斐波那契数密切相关。

在 AVL 树的所有操作中，除去插入操作外，所有的树操作都可以以时间$O(\log N)$执行。当进行插入时，我们需要更新通向根节点路径上那些节点的平衡信息，但插入一个节点可能破坏 AVL 树的特性（例如将$6$插入到图 4-8 中的 AVL 树中会破坏节点(8)的平衡条件）。如果发生这种情况，就需要通过**旋转**操作来恢复节点平衡性质。由于任意节点最多有两个儿子，因此高度不平衡时，节点$n$的两棵子树的高度差为$2$。这种不平衡可能出现在下面的四种情况中：

-   情形$a$：对 n 的左儿子的左子树进行一次插入
-   情形$b$：对 n 的左儿子的右子树进行一次插入
-   情形$c$：对 n 的右儿子的左子树进行一次插入
-   情形$d$：对 n 的右儿子的右子树进行一次插入

第一种情况是插入发生在“外边”的情况（即左-左或右-右的情况），该情况通过对树的一次**单旋转**完成调整。第二种情况是发生在“内部”的情形（即左-右或右-左的情况）。该情况通过一次**双旋转**完成调整。

#### 单旋转

图 4-9 显示单旋转如何调整情形$a$和情形$d$。旋转前的图在左边，而旋转后的图在右边。对情形$a$来说，节点$B$不满足 AVL 平衡特性，因为它的左子树比右子树深$2$层。为使树恢复平衡，我们把$D$上移一层，并把$B$下移一层。对情形$d$来说，节点$C$不满足 AVL 平衡特性，为使树恢复平衡，我们把$D$上移一层，并把$C$下移一层。

<image  height="240" src="../../../Assets/Images/ch4/4-9.png">

图 4-9 调整情形$a$和$d$的单旋转

#### 双旋转

单旋转对情形$b$和$c$无效，问题在于当子树的根太深时，单旋转没有减低它的深度。

图 4-10 显示双旋转如何调整情形$b$和情形$c$。 在情形$b$中。节点$A$不满足 AVL 平衡特性，因为它的左子树比右子树深$2$层，而在$B$和$A$之间的单旋转又解决不了问题，唯一的选择就是把$E$当作新的根，这将使$E$是$B$的左儿子，$A$是它的右儿子，同时$E$原先的左儿子成为$B$的右儿子，而$E$原先的右儿子成为$A$的左儿子。

<image  height="240" src="../../../Assets/Images/ch4/4-10.png">

图 4-10 调整情形$b$和$c$的双旋转

### 代码位置

---

[SourceCode/Tree/AvlTree/AvlTree.ts](../../../SourceCode/Tree/AVLTree/AVLTree.ts)
